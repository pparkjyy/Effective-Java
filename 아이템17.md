# 4-17 // 변경 가능성을 최소화하라

## 왜?
불변 클래스는 가변 클래스보다 설계,구현 하기가 쉽다. 또한 오류가 생길 여지도 적고 훨씬 안전하다.



## 클래스를 불변으로 만드는 5가지 규칙

1. 객체 상태를 변경하는 메서드(변경자)를 제공하지 않는다.( ex: setter 메서드 )

2. 클래스를 확장할 수 없도록 한다.

3. 모든 필드를 final로 선언한다.

4. 모든 필드를 private 으로 선언한다.

5. 자신 외에는 내부 가변 컴포넌트에 접근할 수 없도록 한다.

   -> 만약 접근자 메서드를 통해 내부 가변 값을 반환해야한다면 방어적복사를 수행하자.

방어적 복사 참고 링크 : https://velog.io/@miot2j/%EC%96%95%EC%9D%80%EB%B3%B5%EC%82%AC-%EA%B9%8A%EC%9D%80%EB%B3%B5%EC%82%AC-%EB%B0%A9%EC%96%B4%EC%A0%81-%EB%B3%B5%EC%82%AC%EB%9E%80

```java
public final class Complex {
    private final double re;
    private final double im;

    public Complex(double re, double im) {
      this.re = re;
      this.im = im;
    }

    public static Complex valueof(double re, double im){
        return new Complex(re, im);
    }
  
    public Complex plus(Complex c) {
        return new Complex(re+c.re, im+c.im);
    }

}
```


## 불변객체의 장점


1. 불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다.


2. 한번 만든 인스턴스는 최대한 재활용 하자. -> 책에서의 예시와 같이 매번 인스턴스 생성은 비효율적이니까 -> 적적 팩터리 고려


3. 방어적 복사가 필요없다
   - 불변 객체를 복사해도 항상 원본이랑 같기 때문에 굳이 clone 메서드나 복사생성자를 제공하지 말자.(불필요한 객체생성 방지)


4. 불변객체는 자유롭게 공유할 수있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.


5. 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.


6. 불변 객체는 그 자체로 실패 원자성을 제공한다.
- 실패 원자성 : 매서드에서 예외가 발생한 후에도 그 객체는 여전히 (메서드 호출 전과 똑같은) 유효한 상태여야 한다.



## 불변객체의 단점

1. 값이 다르면 반드시 독립된 객체로 만들어야 한다.

   -> 값의 가짓수가 많다면 이들을 많이 만드는데 많은 비용이 든다.




## 불변클래스 설계

1. final 클래스로 선언
2. 모든 생성자를 private 혹은 package-private 으로 만들고 정적팩터리(아이템1) 을 제공하자 이 방법이 조금더 유연한 방법이다.



## 정리

1. 클래스는 꼭필요한 경우가 아니라면 불변이어야 한다.
   - getter 메서드가 있다고 해서 무조건 setter 를 만들지는 말자.
   
2.  불변으로 만들 수없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.
   - 꼭 변경해야 할 필드를 뺀 나머지는 final로 선언하자.
   - 다른 합당한 이유가 없다면 모든 필드는 private final 이어야한다.


3. 생성자는 불변식 설정이 모두 완료된 ,초기화가 완벽히 끝난 상태의 객체를 생성해야한다.
   - 확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public 으로 제공 하면 안된다.